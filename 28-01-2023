1.Minimum element in BST
code:
class Tree {
    int minValue(Node node) {
        if(node==null){
            return -1;
        }
        while(node.left!=null){
            node=node.left;
        }
        return node.data;
    }
}
2.Lowest Common Ancestor of a Binary Search Tree
code:
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val==p.val || root.val==q.val){
            return root;
        }
        if(root.val<p.val && root.val<q.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        else if(root.val>p.val && root.val>q.val){
            return lowestCommonAncestor(root.left,p,q);
        }
        return root;
    }
}
3.Insert into a Binary Search Tree
code:
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        TreeNode cur= new TreeNode(val);
        if(root==null){
            return cur;
        }
        TreeNode res=root;
        TreeNode p=null;
        while(root!=null){
            p=root;
            if(val<root.val){
                root=root.left;
            }
            else{
                root=root.right;
            }
        }
        if(val<p.val){
            p.left=cur;
        }
        else{
            p.right=cur;
        }
        return res;
    }
}
4.Delete a node in BST
code:
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null){
            return root;
        }
        TreeNode p=null;
        TreeNode cur=root;
        while(cur!=null && cur.val!=key){
            p=cur;
            if(key<cur.val){
                cur=cur.left;
            }
            else{
                cur=cur.right;
            }
        }
        if(cur!=null){
            if(cur.left==null && cur.right==null && p!=null){
                if(p.val>cur.val){
                    p.left=null;
                }
                else{
                    p.right=null;
                }
                return root;
            }
        if(cur.left!=null && cur.right!=null){
            TreeNode temp=cur.right;
            p=cur;
            while(temp.left!=null){
                p=temp;
                temp=temp.left;
            }
            cur.val=temp.val;
            cur=temp;
        }
        if(key==root.val){
            if(root.left!=null){
            root=root.left;
            }
            else{
               root=root.right;
            }
        return root;
        }
        if(p.val>cur.val){
            if(cur.left!=null){
                p.left=cur.left;
            }
            else{
                p.left=cur.right;
            }
        }
        else{
            if(cur.left!=null){
                p.right=cur.left;
            }
            else{
                p.right=cur.right;
            }
        }
        }
        return root;
    }
}
